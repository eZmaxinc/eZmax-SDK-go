/*
eZmax API Definition (Full)

This API expose all the functionnalities for the eZmax and eZsign applications.

API version: 1.2.2
Contact: support-api@ezmax.ca
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eZmaxApi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectUsergroupmembershipAPIService ObjectUsergroupmembershipAPI service
type ObjectUsergroupmembershipAPIService service

type ApiUsergroupmembershipCreateObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectUsergroupmembershipAPIService
	usergroupmembershipCreateObjectV1Request *UsergroupmembershipCreateObjectV1Request
}

func (r ApiUsergroupmembershipCreateObjectV1Request) UsergroupmembershipCreateObjectV1Request(usergroupmembershipCreateObjectV1Request UsergroupmembershipCreateObjectV1Request) ApiUsergroupmembershipCreateObjectV1Request {
	r.usergroupmembershipCreateObjectV1Request = &usergroupmembershipCreateObjectV1Request
	return r
}

func (r ApiUsergroupmembershipCreateObjectV1Request) Execute() (*UsergroupmembershipCreateObjectV1Response, *http.Response, error) {
	return r.ApiService.UsergroupmembershipCreateObjectV1Execute(r)
}

/*
UsergroupmembershipCreateObjectV1 Create a new Usergroupmembership

The endpoint allows to create one or many elements at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsergroupmembershipCreateObjectV1Request
*/
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipCreateObjectV1(ctx context.Context) ApiUsergroupmembershipCreateObjectV1Request {
	return ApiUsergroupmembershipCreateObjectV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsergroupmembershipCreateObjectV1Response
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipCreateObjectV1Execute(r ApiUsergroupmembershipCreateObjectV1Request) (*UsergroupmembershipCreateObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsergroupmembershipCreateObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectUsergroupmembershipAPIService.UsergroupmembershipCreateObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/usergroupmembership"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.usergroupmembershipCreateObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("usergroupmembershipCreateObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usergroupmembershipCreateObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsergroupmembershipDeleteObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectUsergroupmembershipAPIService
	pkiUsergroupmembershipID int32
}

func (r ApiUsergroupmembershipDeleteObjectV1Request) Execute() (*UsergroupmembershipDeleteObjectV1Response, *http.Response, error) {
	return r.ApiService.UsergroupmembershipDeleteObjectV1Execute(r)
}

/*
UsergroupmembershipDeleteObjectV1 Delete an existing Usergroupmembership



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiUsergroupmembershipID
 @return ApiUsergroupmembershipDeleteObjectV1Request
*/
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipDeleteObjectV1(ctx context.Context, pkiUsergroupmembershipID int32) ApiUsergroupmembershipDeleteObjectV1Request {
	return ApiUsergroupmembershipDeleteObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiUsergroupmembershipID: pkiUsergroupmembershipID,
	}
}

// Execute executes the request
//  @return UsergroupmembershipDeleteObjectV1Response
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipDeleteObjectV1Execute(r ApiUsergroupmembershipDeleteObjectV1Request) (*UsergroupmembershipDeleteObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsergroupmembershipDeleteObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectUsergroupmembershipAPIService.UsergroupmembershipDeleteObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/usergroupmembership/{pkiUsergroupmembershipID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiUsergroupmembershipID"+"}", url.PathEscape(parameterValueToString(r.pkiUsergroupmembershipID, "pkiUsergroupmembershipID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiUsergroupmembershipID < 0 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be greater than 0")
	}
	if r.pkiUsergroupmembershipID > 65535 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be less than 65535")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsergroupmembershipEditObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectUsergroupmembershipAPIService
	pkiUsergroupmembershipID int32
	usergroupmembershipEditObjectV1Request *UsergroupmembershipEditObjectV1Request
}

func (r ApiUsergroupmembershipEditObjectV1Request) UsergroupmembershipEditObjectV1Request(usergroupmembershipEditObjectV1Request UsergroupmembershipEditObjectV1Request) ApiUsergroupmembershipEditObjectV1Request {
	r.usergroupmembershipEditObjectV1Request = &usergroupmembershipEditObjectV1Request
	return r
}

func (r ApiUsergroupmembershipEditObjectV1Request) Execute() (*UsergroupmembershipEditObjectV1Response, *http.Response, error) {
	return r.ApiService.UsergroupmembershipEditObjectV1Execute(r)
}

/*
UsergroupmembershipEditObjectV1 Edit an existing Usergroupmembership



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiUsergroupmembershipID
 @return ApiUsergroupmembershipEditObjectV1Request
*/
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipEditObjectV1(ctx context.Context, pkiUsergroupmembershipID int32) ApiUsergroupmembershipEditObjectV1Request {
	return ApiUsergroupmembershipEditObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiUsergroupmembershipID: pkiUsergroupmembershipID,
	}
}

// Execute executes the request
//  @return UsergroupmembershipEditObjectV1Response
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipEditObjectV1Execute(r ApiUsergroupmembershipEditObjectV1Request) (*UsergroupmembershipEditObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsergroupmembershipEditObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectUsergroupmembershipAPIService.UsergroupmembershipEditObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/usergroupmembership/{pkiUsergroupmembershipID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiUsergroupmembershipID"+"}", url.PathEscape(parameterValueToString(r.pkiUsergroupmembershipID, "pkiUsergroupmembershipID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiUsergroupmembershipID < 0 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be greater than 0")
	}
	if r.pkiUsergroupmembershipID > 65535 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be less than 65535")
	}
	if r.usergroupmembershipEditObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("usergroupmembershipEditObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usergroupmembershipEditObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsergroupmembershipGetObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectUsergroupmembershipAPIService
	pkiUsergroupmembershipID int32
}

func (r ApiUsergroupmembershipGetObjectV2Request) Execute() (*UsergroupmembershipGetObjectV2Response, *http.Response, error) {
	return r.ApiService.UsergroupmembershipGetObjectV2Execute(r)
}

/*
UsergroupmembershipGetObjectV2 Retrieve an existing Usergroupmembership



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiUsergroupmembershipID
 @return ApiUsergroupmembershipGetObjectV2Request
*/
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipGetObjectV2(ctx context.Context, pkiUsergroupmembershipID int32) ApiUsergroupmembershipGetObjectV2Request {
	return ApiUsergroupmembershipGetObjectV2Request{
		ApiService: a,
		ctx: ctx,
		pkiUsergroupmembershipID: pkiUsergroupmembershipID,
	}
}

// Execute executes the request
//  @return UsergroupmembershipGetObjectV2Response
func (a *ObjectUsergroupmembershipAPIService) UsergroupmembershipGetObjectV2Execute(r ApiUsergroupmembershipGetObjectV2Request) (*UsergroupmembershipGetObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsergroupmembershipGetObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectUsergroupmembershipAPIService.UsergroupmembershipGetObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/usergroupmembership/{pkiUsergroupmembershipID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiUsergroupmembershipID"+"}", url.PathEscape(parameterValueToString(r.pkiUsergroupmembershipID, "pkiUsergroupmembershipID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiUsergroupmembershipID < 0 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be greater than 0")
	}
	if r.pkiUsergroupmembershipID > 65535 {
		return localVarReturnValue, nil, reportError("pkiUsergroupmembershipID must be less than 65535")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
