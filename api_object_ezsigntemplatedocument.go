/*
eZmax API Definition (Full)

This API expose all the functionnalities for the eZmax and eZsign applications.

API version: 1.2.1
Contact: support-api@ezmax.ca
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eZmaxApi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectEzsigntemplatedocumentAPIService ObjectEzsigntemplatedocumentAPI service
type ObjectEzsigntemplatedocumentAPIService service

type ApiEzsigntemplatedocumentCreateObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	ezsigntemplatedocumentCreateObjectV1Request *EzsigntemplatedocumentCreateObjectV1Request
}

func (r ApiEzsigntemplatedocumentCreateObjectV1Request) EzsigntemplatedocumentCreateObjectV1Request(ezsigntemplatedocumentCreateObjectV1Request EzsigntemplatedocumentCreateObjectV1Request) ApiEzsigntemplatedocumentCreateObjectV1Request {
	r.ezsigntemplatedocumentCreateObjectV1Request = &ezsigntemplatedocumentCreateObjectV1Request
	return r
}

func (r ApiEzsigntemplatedocumentCreateObjectV1Request) Execute() (*EzsigntemplatedocumentCreateObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentCreateObjectV1Execute(r)
}

/*
EzsigntemplatedocumentCreateObjectV1 Create a new Ezsigntemplatedocument

The endpoint allows to create one or many elements at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsigntemplatedocumentCreateObjectV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentCreateObjectV1(ctx context.Context) ApiEzsigntemplatedocumentCreateObjectV1Request {
	return ApiEzsigntemplatedocumentCreateObjectV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentCreateObjectV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentCreateObjectV1Execute(r ApiEzsigntemplatedocumentCreateObjectV1Request) (*EzsigntemplatedocumentCreateObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentCreateObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentCreateObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsigntemplatedocumentCreateObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentCreateObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentCreateObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseErrorSTemporaryFileUrl
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request *EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request) EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request(ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request) ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request {
	r.ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request = &ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request
	return r
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request) Execute() (*EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Execute(r)
}

/*
EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1 Edit multiple Ezsigntemplatedocumentpagerecognitions

Edit multiple Ezsigntemplatedocumentpagerecognitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request {
	return ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Execute(r ApiEzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request) (*EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/editEzsigntemplatedocumentpagerecognitions"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentEditEzsigntemplatedocumentpagerecognitionsV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request *EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request) EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request(ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request) ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request {
	r.ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request = &ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request
	return r
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request) Execute() (*EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Execute(r)
}

/*
EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1 Edit multiple Ezsigntemplateformfieldgroups

Using this endpoint, you can edit multiple Ezsigntemplateformfieldgroups at the same time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request {
	return ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Execute(r ApiEzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request) (*EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/editEzsigntemplateformfieldgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentEditEzsigntemplateformfieldgroupsV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request *EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request) EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request(ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request) ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request {
	r.ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request = &ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request
	return r
}

func (r ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request) Execute() (*EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Execute(r)
}

/*
EzsigntemplatedocumentEditEzsigntemplatesignaturesV1 Edit multiple Ezsigntemplatesignatures

Using this endpoint, you can edit multiple Ezsigntemplatesignatures at the same time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplatesignaturesV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request {
	return ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Execute(r ApiEzsigntemplatedocumentEditEzsigntemplatesignaturesV1Request) (*EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentEditEzsigntemplatesignaturesV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentEditEzsigntemplatesignaturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/editEzsigntemplatesignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentEditEzsigntemplatesignaturesV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentEditObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentEditObjectV1Request *EzsigntemplatedocumentEditObjectV1Request
}

func (r ApiEzsigntemplatedocumentEditObjectV1Request) EzsigntemplatedocumentEditObjectV1Request(ezsigntemplatedocumentEditObjectV1Request EzsigntemplatedocumentEditObjectV1Request) ApiEzsigntemplatedocumentEditObjectV1Request {
	r.ezsigntemplatedocumentEditObjectV1Request = &ezsigntemplatedocumentEditObjectV1Request
	return r
}

func (r ApiEzsigntemplatedocumentEditObjectV1Request) Execute() (*EzsigntemplatedocumentEditObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentEditObjectV1Execute(r)
}

/*
EzsigntemplatedocumentEditObjectV1 Edit an existing Ezsigntemplatedocument



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentEditObjectV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditObjectV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentEditObjectV1Request {
	return ApiEzsigntemplatedocumentEditObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentEditObjectV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentEditObjectV1Execute(r ApiEzsigntemplatedocumentEditObjectV1Request) (*EzsigntemplatedocumentEditObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentEditObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentEditObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentEditObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentEditObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentEditObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseErrorSTemporaryFileUrl
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentExtractTextV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentExtractTextV1Request *EzsigntemplatedocumentExtractTextV1Request
}

func (r ApiEzsigntemplatedocumentExtractTextV1Request) EzsigntemplatedocumentExtractTextV1Request(ezsigntemplatedocumentExtractTextV1Request EzsigntemplatedocumentExtractTextV1Request) ApiEzsigntemplatedocumentExtractTextV1Request {
	r.ezsigntemplatedocumentExtractTextV1Request = &ezsigntemplatedocumentExtractTextV1Request
	return r
}

func (r ApiEzsigntemplatedocumentExtractTextV1Request) Execute() (*EzsigntemplatedocumentExtractTextV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentExtractTextV1Execute(r)
}

/*
EzsigntemplatedocumentExtractTextV1 Extract text from Ezsigntemplatedocument area

Extract text from Ezsigntemplatedocument area

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentExtractTextV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentExtractTextV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentExtractTextV1Request {
	return ApiEzsigntemplatedocumentExtractTextV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentExtractTextV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentExtractTextV1Execute(r ApiEzsigntemplatedocumentExtractTextV1Request) (*EzsigntemplatedocumentExtractTextV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentExtractTextV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentExtractTextV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/extractText"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentExtractTextV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentExtractTextV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentExtractTextV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentFlattenV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	body *map[string]interface{}
}

func (r ApiEzsigntemplatedocumentFlattenV1Request) Body(body map[string]interface{}) ApiEzsigntemplatedocumentFlattenV1Request {
	r.body = &body
	return r
}

func (r ApiEzsigntemplatedocumentFlattenV1Request) Execute() (*EzsigntemplatedocumentFlattenV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentFlattenV1Execute(r)
}

/*
EzsigntemplatedocumentFlattenV1 Flatten

Flatten an Ezsigntemplatedocument signatures, forms and annotations. This process finalizes the PDF so that the forms and annotations become part of the document content and cannot be edited.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentFlattenV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentFlattenV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentFlattenV1Request {
	return ApiEzsigntemplatedocumentFlattenV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentFlattenV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentFlattenV1Execute(r ApiEzsigntemplatedocumentFlattenV1Request) (*EzsigntemplatedocumentFlattenV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentFlattenV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentFlattenV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/flatten"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
}

func (r ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request) Execute() (*EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Execute(r)
}

/*
EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1 Retrieve an existing Ezsigntemplatedocument's Ezsigntemplatedocumentpagerecognitions



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request {
	return ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Execute(r ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Request) (*EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetEzsigntemplatedocumentpagerecognitionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/getEzsigntemplatedocumentpagerecognitions"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
}

func (r ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request) Execute() (*EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Execute(r)
}

/*
EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1 Retrieve an existing Ezsigntemplatedocument's Ezsigntemplatedocumentpages



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request {
	return ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Execute(r ApiEzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Request) (*EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetEzsigntemplatedocumentpagesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/getEzsigntemplatedocumentpages"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
}

func (r ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request) Execute() (*EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Execute(r)
}

/*
EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1 Retrieve an existing Ezsigntemplatedocument's Ezsigntemplateformfieldgroups



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request {
	return ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Execute(r ApiEzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Request) (*EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetEzsigntemplateformfieldgroupsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/getEzsigntemplateformfieldgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
}

func (r ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request) Execute() (*EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Execute(r)
}

/*
EzsigntemplatedocumentGetEzsigntemplatesignaturesV1 Retrieve an existing Ezsigntemplatedocument's Ezsigntemplatesignatures



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatesignaturesV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request {
	return ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Execute(r ApiEzsigntemplatedocumentGetEzsigntemplatesignaturesV1Request) (*EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetEzsigntemplatesignaturesV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetEzsigntemplatesignaturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/getEzsigntemplatesignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
}

func (r ApiEzsigntemplatedocumentGetObjectV2Request) Execute() (*EzsigntemplatedocumentGetObjectV2Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetObjectV2Execute(r)
}

/*
EzsigntemplatedocumentGetObjectV2 Retrieve an existing Ezsigntemplatedocument



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetObjectV2Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetObjectV2(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetObjectV2Request {
	return ApiEzsigntemplatedocumentGetObjectV2Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetObjectV2Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetObjectV2Execute(r ApiEzsigntemplatedocumentGetObjectV2Request) (*EzsigntemplatedocumentGetObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentGetWordsPositionsV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentGetWordsPositionsV1Request *EzsigntemplatedocumentGetWordsPositionsV1Request
}

func (r ApiEzsigntemplatedocumentGetWordsPositionsV1Request) EzsigntemplatedocumentGetWordsPositionsV1Request(ezsigntemplatedocumentGetWordsPositionsV1Request EzsigntemplatedocumentGetWordsPositionsV1Request) ApiEzsigntemplatedocumentGetWordsPositionsV1Request {
	r.ezsigntemplatedocumentGetWordsPositionsV1Request = &ezsigntemplatedocumentGetWordsPositionsV1Request
	return r
}

func (r ApiEzsigntemplatedocumentGetWordsPositionsV1Request) Execute() (*EzsigntemplatedocumentGetWordsPositionsV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentGetWordsPositionsV1Execute(r)
}

/*
EzsigntemplatedocumentGetWordsPositionsV1 Retrieve positions X,Y of given words from a Ezsigntemplatedocument



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentGetWordsPositionsV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetWordsPositionsV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentGetWordsPositionsV1Request {
	return ApiEzsigntemplatedocumentGetWordsPositionsV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentGetWordsPositionsV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentGetWordsPositionsV1Execute(r ApiEzsigntemplatedocumentGetWordsPositionsV1Request) (*EzsigntemplatedocumentGetWordsPositionsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentGetWordsPositionsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentGetWordsPositionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}/getWordsPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentGetWordsPositionsV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentGetWordsPositionsV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentGetWordsPositionsV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsigntemplatedocumentPatchObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsigntemplatedocumentAPIService
	pkiEzsigntemplatedocumentID int32
	ezsigntemplatedocumentPatchObjectV1Request *EzsigntemplatedocumentPatchObjectV1Request
}

func (r ApiEzsigntemplatedocumentPatchObjectV1Request) EzsigntemplatedocumentPatchObjectV1Request(ezsigntemplatedocumentPatchObjectV1Request EzsigntemplatedocumentPatchObjectV1Request) ApiEzsigntemplatedocumentPatchObjectV1Request {
	r.ezsigntemplatedocumentPatchObjectV1Request = &ezsigntemplatedocumentPatchObjectV1Request
	return r
}

func (r ApiEzsigntemplatedocumentPatchObjectV1Request) Execute() (*EzsigntemplatedocumentPatchObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsigntemplatedocumentPatchObjectV1Execute(r)
}

/*
EzsigntemplatedocumentPatchObjectV1 Patch an existing Ezsigntemplatedocument



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsigntemplatedocumentID
 @return ApiEzsigntemplatedocumentPatchObjectV1Request
*/
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentPatchObjectV1(ctx context.Context, pkiEzsigntemplatedocumentID int32) ApiEzsigntemplatedocumentPatchObjectV1Request {
	return ApiEzsigntemplatedocumentPatchObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsigntemplatedocumentID: pkiEzsigntemplatedocumentID,
	}
}

// Execute executes the request
//  @return EzsigntemplatedocumentPatchObjectV1Response
func (a *ObjectEzsigntemplatedocumentAPIService) EzsigntemplatedocumentPatchObjectV1Execute(r ApiEzsigntemplatedocumentPatchObjectV1Request) (*EzsigntemplatedocumentPatchObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsigntemplatedocumentPatchObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsigntemplatedocumentAPIService.EzsigntemplatedocumentPatchObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsigntemplatedocument/{pkiEzsigntemplatedocumentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsigntemplatedocumentID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsigntemplatedocumentID, "pkiEzsigntemplatedocumentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsigntemplatedocumentID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsigntemplatedocumentID must be greater than 0")
	}
	if r.ezsigntemplatedocumentPatchObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsigntemplatedocumentPatchObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsigntemplatedocumentPatchObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
