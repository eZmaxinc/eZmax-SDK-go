/*
eZmax API Definition (Full)

This API expose all the functionnalities for the eZmax and eZsign applications.

API version: 1.2.2
Contact: support-api@ezmax.ca
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eZmaxApi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectEzsignsignatureAPIService ObjectEzsignsignatureAPI service
type ObjectEzsignsignatureAPIService service

type ApiEzsignsignatureCreateObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	ezsignsignatureCreateObjectV1Request *[]EzsignsignatureCreateObjectV1Request
}

func (r ApiEzsignsignatureCreateObjectV1Request) EzsignsignatureCreateObjectV1Request(ezsignsignatureCreateObjectV1Request []EzsignsignatureCreateObjectV1Request) ApiEzsignsignatureCreateObjectV1Request {
	r.ezsignsignatureCreateObjectV1Request = &ezsignsignatureCreateObjectV1Request
	return r
}

func (r ApiEzsignsignatureCreateObjectV1Request) Execute() (*EzsignsignatureCreateObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureCreateObjectV1Execute(r)
}

/*
EzsignsignatureCreateObjectV1 Create a new Ezsignsignature

The endpoint allows to create one or many elements at once.

The array can contain simple (Just the object) or compound (The object and its child) objects.

Creating compound elements allows to reduce the multiple requests to create all child objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignsignatureCreateObjectV1Request

Deprecated
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV1(ctx context.Context) ApiEzsignsignatureCreateObjectV1Request {
	return ApiEzsignsignatureCreateObjectV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignsignatureCreateObjectV1Response
// Deprecated
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV1Execute(r ApiEzsignsignatureCreateObjectV1Request) (*EzsignsignatureCreateObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureCreateObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureCreateObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignsignature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsignsignatureCreateObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignsignatureCreateObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignsignatureCreateObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureCreateObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	ezsignsignatureCreateObjectV2Request *EzsignsignatureCreateObjectV2Request
}

func (r ApiEzsignsignatureCreateObjectV2Request) EzsignsignatureCreateObjectV2Request(ezsignsignatureCreateObjectV2Request EzsignsignatureCreateObjectV2Request) ApiEzsignsignatureCreateObjectV2Request {
	r.ezsignsignatureCreateObjectV2Request = &ezsignsignatureCreateObjectV2Request
	return r
}

func (r ApiEzsignsignatureCreateObjectV2Request) Execute() (*EzsignsignatureCreateObjectV2Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureCreateObjectV2Execute(r)
}

/*
EzsignsignatureCreateObjectV2 Create a new Ezsignsignature

The endpoint allows to create one or many elements at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignsignatureCreateObjectV2Request

Deprecated
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV2(ctx context.Context) ApiEzsignsignatureCreateObjectV2Request {
	return ApiEzsignsignatureCreateObjectV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignsignatureCreateObjectV2Response
// Deprecated
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV2Execute(r ApiEzsignsignatureCreateObjectV2Request) (*EzsignsignatureCreateObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureCreateObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureCreateObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/ezsignsignature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsignsignatureCreateObjectV2Request == nil {
		return localVarReturnValue, nil, reportError("ezsignsignatureCreateObjectV2Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignsignatureCreateObjectV2Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureCreateObjectV3Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	ezsignsignatureCreateObjectV3Request *EzsignsignatureCreateObjectV3Request
}

func (r ApiEzsignsignatureCreateObjectV3Request) EzsignsignatureCreateObjectV3Request(ezsignsignatureCreateObjectV3Request EzsignsignatureCreateObjectV3Request) ApiEzsignsignatureCreateObjectV3Request {
	r.ezsignsignatureCreateObjectV3Request = &ezsignsignatureCreateObjectV3Request
	return r
}

func (r ApiEzsignsignatureCreateObjectV3Request) Execute() (*EzsignsignatureCreateObjectV3Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureCreateObjectV3Execute(r)
}

/*
EzsignsignatureCreateObjectV3 Create a new Ezsignsignature

The endpoint allows to create one or many elements at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignsignatureCreateObjectV3Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV3(ctx context.Context) ApiEzsignsignatureCreateObjectV3Request {
	return ApiEzsignsignatureCreateObjectV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignsignatureCreateObjectV3Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureCreateObjectV3Execute(r ApiEzsignsignatureCreateObjectV3Request) (*EzsignsignatureCreateObjectV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureCreateObjectV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureCreateObjectV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/3/object/ezsignsignature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsignsignatureCreateObjectV3Request == nil {
		return localVarReturnValue, nil, reportError("ezsignsignatureCreateObjectV3Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignsignatureCreateObjectV3Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureDeleteObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	pkiEzsignsignatureID int32
}

func (r ApiEzsignsignatureDeleteObjectV1Request) Execute() (*EzsignsignatureDeleteObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureDeleteObjectV1Execute(r)
}

/*
EzsignsignatureDeleteObjectV1 Delete an existing Ezsignsignature



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignsignatureID
 @return ApiEzsignsignatureDeleteObjectV1Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureDeleteObjectV1(ctx context.Context, pkiEzsignsignatureID int32) ApiEzsignsignatureDeleteObjectV1Request {
	return ApiEzsignsignatureDeleteObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignsignatureID: pkiEzsignsignatureID,
	}
}

// Execute executes the request
//  @return EzsignsignatureDeleteObjectV1Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureDeleteObjectV1Execute(r ApiEzsignsignatureDeleteObjectV1Request) (*EzsignsignatureDeleteObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureDeleteObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureDeleteObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignsignature/{pkiEzsignsignatureID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignsignatureID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignsignatureID, "pkiEzsignsignatureID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignsignatureID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignsignatureID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureEditObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	pkiEzsignsignatureID int32
	ezsignsignatureEditObjectV2Request *EzsignsignatureEditObjectV2Request
}

func (r ApiEzsignsignatureEditObjectV2Request) EzsignsignatureEditObjectV2Request(ezsignsignatureEditObjectV2Request EzsignsignatureEditObjectV2Request) ApiEzsignsignatureEditObjectV2Request {
	r.ezsignsignatureEditObjectV2Request = &ezsignsignatureEditObjectV2Request
	return r
}

func (r ApiEzsignsignatureEditObjectV2Request) Execute() (*EzsignsignatureEditObjectV2Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureEditObjectV2Execute(r)
}

/*
EzsignsignatureEditObjectV2 Edit an existing Ezsignsignature



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignsignatureID
 @return ApiEzsignsignatureEditObjectV2Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureEditObjectV2(ctx context.Context, pkiEzsignsignatureID int32) ApiEzsignsignatureEditObjectV2Request {
	return ApiEzsignsignatureEditObjectV2Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignsignatureID: pkiEzsignsignatureID,
	}
}

// Execute executes the request
//  @return EzsignsignatureEditObjectV2Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureEditObjectV2Execute(r ApiEzsignsignatureEditObjectV2Request) (*EzsignsignatureEditObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureEditObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureEditObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/ezsignsignature/{pkiEzsignsignatureID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignsignatureID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignsignatureID, "pkiEzsignsignatureID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignsignatureID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignsignatureID must be greater than 0")
	}
	if r.ezsignsignatureEditObjectV2Request == nil {
		return localVarReturnValue, nil, reportError("ezsignsignatureEditObjectV2Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignsignatureEditObjectV2Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureGetEzsignsignatureattachmentV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	pkiEzsignsignatureID int32
}

func (r ApiEzsignsignatureGetEzsignsignatureattachmentV1Request) Execute() (*EzsignsignatureGetEzsignsignatureattachmentV1Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureGetEzsignsignatureattachmentV1Execute(r)
}

/*
EzsignsignatureGetEzsignsignatureattachmentV1 Retrieve an existing Ezsignsignature's Ezsignsignatureattachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignsignatureID
 @return ApiEzsignsignatureGetEzsignsignatureattachmentV1Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetEzsignsignatureattachmentV1(ctx context.Context, pkiEzsignsignatureID int32) ApiEzsignsignatureGetEzsignsignatureattachmentV1Request {
	return ApiEzsignsignatureGetEzsignsignatureattachmentV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignsignatureID: pkiEzsignsignatureID,
	}
}

// Execute executes the request
//  @return EzsignsignatureGetEzsignsignatureattachmentV1Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetEzsignsignatureattachmentV1Execute(r ApiEzsignsignatureGetEzsignsignatureattachmentV1Request) (*EzsignsignatureGetEzsignsignatureattachmentV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureGetEzsignsignatureattachmentV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureGetEzsignsignatureattachmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignsignature/{pkiEzsignsignatureID}/getEzsignsignatureattachment"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignsignatureID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignsignatureID, "pkiEzsignsignatureID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignsignatureID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignsignatureID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
}

func (r ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request) Execute() (*EzsignsignatureGetEzsignsignaturesAutomaticV1Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureGetEzsignsignaturesAutomaticV1Execute(r)
}

/*
EzsignsignatureGetEzsignsignaturesAutomaticV1 Retrieve all automatic Ezsignsignatures

Return all the Ezsignsignatures that can be signed by the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetEzsignsignaturesAutomaticV1(ctx context.Context) ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request {
	return ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignsignatureGetEzsignsignaturesAutomaticV1Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetEzsignsignaturesAutomaticV1Execute(r ApiEzsignsignatureGetEzsignsignaturesAutomaticV1Request) (*EzsignsignatureGetEzsignsignaturesAutomaticV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureGetEzsignsignaturesAutomaticV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureGetEzsignsignaturesAutomaticV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignsignature/getEzsignsignaturesAutomatic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureGetObjectV3Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	pkiEzsignsignatureID int32
}

func (r ApiEzsignsignatureGetObjectV3Request) Execute() (*EzsignsignatureGetObjectV3Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureGetObjectV3Execute(r)
}

/*
EzsignsignatureGetObjectV3 Retrieve an existing Ezsignsignature



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignsignatureID
 @return ApiEzsignsignatureGetObjectV3Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetObjectV3(ctx context.Context, pkiEzsignsignatureID int32) ApiEzsignsignatureGetObjectV3Request {
	return ApiEzsignsignatureGetObjectV3Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignsignatureID: pkiEzsignsignatureID,
	}
}

// Execute executes the request
//  @return EzsignsignatureGetObjectV3Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureGetObjectV3Execute(r ApiEzsignsignatureGetObjectV3Request) (*EzsignsignatureGetObjectV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureGetObjectV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureGetObjectV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/3/object/ezsignsignature/{pkiEzsignsignatureID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignsignatureID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignsignatureID, "pkiEzsignsignatureID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignsignatureID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignsignatureID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignsignatureSignV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignsignatureAPIService
	pkiEzsignsignatureID int32
	ezsignsignatureSignV1Request *EzsignsignatureSignV1Request
}

func (r ApiEzsignsignatureSignV1Request) EzsignsignatureSignV1Request(ezsignsignatureSignV1Request EzsignsignatureSignV1Request) ApiEzsignsignatureSignV1Request {
	r.ezsignsignatureSignV1Request = &ezsignsignatureSignV1Request
	return r
}

func (r ApiEzsignsignatureSignV1Request) Execute() (*EzsignsignatureSignV1Response, *http.Response, error) {
	return r.ApiService.EzsignsignatureSignV1Execute(r)
}

/*
EzsignsignatureSignV1 Sign the Ezsignsignature



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignsignatureID
 @return ApiEzsignsignatureSignV1Request
*/
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureSignV1(ctx context.Context, pkiEzsignsignatureID int32) ApiEzsignsignatureSignV1Request {
	return ApiEzsignsignatureSignV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignsignatureID: pkiEzsignsignatureID,
	}
}

// Execute executes the request
//  @return EzsignsignatureSignV1Response
func (a *ObjectEzsignsignatureAPIService) EzsignsignatureSignV1Execute(r ApiEzsignsignatureSignV1Request) (*EzsignsignatureSignV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignsignatureSignV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignsignatureAPIService.EzsignsignatureSignV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignsignature/{pkiEzsignsignatureID}/sign"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignsignatureID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignsignatureID, "pkiEzsignsignatureID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignsignatureID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignsignatureID must be greater than 0")
	}
	if r.ezsignsignatureSignV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignsignatureSignV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignsignatureSignV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
