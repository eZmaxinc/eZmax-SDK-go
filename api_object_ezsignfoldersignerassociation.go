/*
eZmax API Definition (Full)

This API expose all the functionnalities for the eZmax and eZsign applications.

API version: 1.2.1
Contact: support-api@ezmax.ca
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eZmaxApi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectEzsignfoldersignerassociationAPIService ObjectEzsignfoldersignerassociationAPI service
type ObjectEzsignfoldersignerassociationAPIService service

type ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
	ezsignfoldersignerassociationCreateEmbeddedUrlV1Request *EzsignfoldersignerassociationCreateEmbeddedUrlV1Request
}

func (r ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request) EzsignfoldersignerassociationCreateEmbeddedUrlV1Request(ezsignfoldersignerassociationCreateEmbeddedUrlV1Request EzsignfoldersignerassociationCreateEmbeddedUrlV1Request) ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request {
	r.ezsignfoldersignerassociationCreateEmbeddedUrlV1Request = &ezsignfoldersignerassociationCreateEmbeddedUrlV1Request
	return r
}

func (r ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request) Execute() (*EzsignfoldersignerassociationCreateEmbeddedUrlV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationCreateEmbeddedUrlV1Execute(r)
}

/*
EzsignfoldersignerassociationCreateEmbeddedUrlV1 Creates an Url to allow embedded signing

This endpoint creates an Url that can be used in a browser or embedded in an I-Frame to allow signing.

The signer Login type must be configured as Embedded.

There will be a list to retrieve informations after the signing happens in the embedded version. To do so, there is a list of parameter to add to your sReturnUrl.

In example: https://www.example.com/sReturl?sParameter1&sParameter2. The sParameter1 et sParameter2 will be replace when we will redirect on the url.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateEmbeddedUrlV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request {
	return ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationCreateEmbeddedUrlV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateEmbeddedUrlV1Execute(r ApiEzsignfoldersignerassociationCreateEmbeddedUrlV1Request) (*EzsignfoldersignerassociationCreateEmbeddedUrlV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationCreateEmbeddedUrlV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationCreateEmbeddedUrlV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/createEmbeddedUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}
	if r.ezsignfoldersignerassociationCreateEmbeddedUrlV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignfoldersignerassociationCreateEmbeddedUrlV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignfoldersignerassociationCreateEmbeddedUrlV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationCreateObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	ezsignfoldersignerassociationCreateObjectV1Request *[]EzsignfoldersignerassociationCreateObjectV1Request
}

func (r ApiEzsignfoldersignerassociationCreateObjectV1Request) EzsignfoldersignerassociationCreateObjectV1Request(ezsignfoldersignerassociationCreateObjectV1Request []EzsignfoldersignerassociationCreateObjectV1Request) ApiEzsignfoldersignerassociationCreateObjectV1Request {
	r.ezsignfoldersignerassociationCreateObjectV1Request = &ezsignfoldersignerassociationCreateObjectV1Request
	return r
}

func (r ApiEzsignfoldersignerassociationCreateObjectV1Request) Execute() (*EzsignfoldersignerassociationCreateObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationCreateObjectV1Execute(r)
}

/*
EzsignfoldersignerassociationCreateObjectV1 Create a new Ezsignfoldersignerassociation

The endpoint allows to create one or many elements at once.

The array can contain simple (Just the object) or compound (The object and its child) objects.

Creating compound elements allows to reduce the multiple requests to create all child objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignfoldersignerassociationCreateObjectV1Request

Deprecated
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateObjectV1(ctx context.Context) ApiEzsignfoldersignerassociationCreateObjectV1Request {
	return ApiEzsignfoldersignerassociationCreateObjectV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationCreateObjectV1Response
// Deprecated
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateObjectV1Execute(r ApiEzsignfoldersignerassociationCreateObjectV1Request) (*EzsignfoldersignerassociationCreateObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationCreateObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationCreateObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsignfoldersignerassociationCreateObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignfoldersignerassociationCreateObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignfoldersignerassociationCreateObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationCreateObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	ezsignfoldersignerassociationCreateObjectV2Request *EzsignfoldersignerassociationCreateObjectV2Request
}

func (r ApiEzsignfoldersignerassociationCreateObjectV2Request) EzsignfoldersignerassociationCreateObjectV2Request(ezsignfoldersignerassociationCreateObjectV2Request EzsignfoldersignerassociationCreateObjectV2Request) ApiEzsignfoldersignerassociationCreateObjectV2Request {
	r.ezsignfoldersignerassociationCreateObjectV2Request = &ezsignfoldersignerassociationCreateObjectV2Request
	return r
}

func (r ApiEzsignfoldersignerassociationCreateObjectV2Request) Execute() (*EzsignfoldersignerassociationCreateObjectV2Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationCreateObjectV2Execute(r)
}

/*
EzsignfoldersignerassociationCreateObjectV2 Create a new Ezsignfoldersignerassociation

The endpoint allows to create one or many elements at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEzsignfoldersignerassociationCreateObjectV2Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateObjectV2(ctx context.Context) ApiEzsignfoldersignerassociationCreateObjectV2Request {
	return ApiEzsignfoldersignerassociationCreateObjectV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationCreateObjectV2Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationCreateObjectV2Execute(r ApiEzsignfoldersignerassociationCreateObjectV2Request) (*EzsignfoldersignerassociationCreateObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationCreateObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationCreateObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/ezsignfoldersignerassociation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ezsignfoldersignerassociationCreateObjectV2Request == nil {
		return localVarReturnValue, nil, reportError("ezsignfoldersignerassociationCreateObjectV2Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignfoldersignerassociationCreateObjectV2Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationDeleteObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
}

func (r ApiEzsignfoldersignerassociationDeleteObjectV1Request) Execute() (*EzsignfoldersignerassociationDeleteObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationDeleteObjectV1Execute(r)
}

/*
EzsignfoldersignerassociationDeleteObjectV1 Delete an existing Ezsignfoldersignerassociation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationDeleteObjectV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationDeleteObjectV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationDeleteObjectV1Request {
	return ApiEzsignfoldersignerassociationDeleteObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationDeleteObjectV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationDeleteObjectV1Execute(r ApiEzsignfoldersignerassociationDeleteObjectV1Request) (*EzsignfoldersignerassociationDeleteObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationDeleteObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationDeleteObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationEditObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
	ezsignfoldersignerassociationEditObjectV1Request *EzsignfoldersignerassociationEditObjectV1Request
}

func (r ApiEzsignfoldersignerassociationEditObjectV1Request) EzsignfoldersignerassociationEditObjectV1Request(ezsignfoldersignerassociationEditObjectV1Request EzsignfoldersignerassociationEditObjectV1Request) ApiEzsignfoldersignerassociationEditObjectV1Request {
	r.ezsignfoldersignerassociationEditObjectV1Request = &ezsignfoldersignerassociationEditObjectV1Request
	return r
}

func (r ApiEzsignfoldersignerassociationEditObjectV1Request) Execute() (*EzsignfoldersignerassociationEditObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationEditObjectV1Execute(r)
}

/*
EzsignfoldersignerassociationEditObjectV1 Edit an existing Ezsignfoldersignerassociation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationEditObjectV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationEditObjectV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationEditObjectV1Request {
	return ApiEzsignfoldersignerassociationEditObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationEditObjectV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationEditObjectV1Execute(r ApiEzsignfoldersignerassociationEditObjectV1Request) (*EzsignfoldersignerassociationEditObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationEditObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationEditObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}
	if r.ezsignfoldersignerassociationEditObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignfoldersignerassociationEditObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignfoldersignerassociationEditObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationForceDisconnectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
	body *map[string]interface{}
}

func (r ApiEzsignfoldersignerassociationForceDisconnectV1Request) Body(body map[string]interface{}) ApiEzsignfoldersignerassociationForceDisconnectV1Request {
	r.body = &body
	return r
}

func (r ApiEzsignfoldersignerassociationForceDisconnectV1Request) Execute() (*EzsignfoldersignerassociationForceDisconnectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationForceDisconnectV1Execute(r)
}

/*
EzsignfoldersignerassociationForceDisconnectV1 Disconnects the Ezsignfoldersignerassociation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationForceDisconnectV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationForceDisconnectV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationForceDisconnectV1Request {
	return ApiEzsignfoldersignerassociationForceDisconnectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationForceDisconnectV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationForceDisconnectV1Execute(r ApiEzsignfoldersignerassociationForceDisconnectV1Request) (*EzsignfoldersignerassociationForceDisconnectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationForceDisconnectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationForceDisconnectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/forceDisconnect"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
}

func (r ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request) Execute() (*EzsignfoldersignerassociationGetInPersonLoginUrlV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationGetInPersonLoginUrlV1Execute(r)
}

/*
EzsignfoldersignerassociationGetInPersonLoginUrlV1 Retrieve a Login Url to allow In-Person signing

This endpoint returns a Login Url that can be used in a browser or embedded in an I-Frame to allow in person signing.

The signer Login type must be configured as In-Person.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetInPersonLoginUrlV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request {
	return ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetInPersonLoginUrlV1Execute(r ApiEzsignfoldersignerassociationGetInPersonLoginUrlV1Request) (*EzsignfoldersignerassociationGetInPersonLoginUrlV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationGetInPersonLoginUrlV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationGetInPersonLoginUrlV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/getInPersonLoginUrl"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationGetObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
}

func (r ApiEzsignfoldersignerassociationGetObjectV1Request) Execute() (*EzsignfoldersignerassociationGetObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationGetObjectV1Execute(r)
}

/*
EzsignfoldersignerassociationGetObjectV1 Retrieve an existing Ezsignfoldersignerassociation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationGetObjectV1Request

Deprecated
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetObjectV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationGetObjectV1Request {
	return ApiEzsignfoldersignerassociationGetObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationGetObjectV1Response
// Deprecated
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetObjectV1Execute(r ApiEzsignfoldersignerassociationGetObjectV1Request) (*EzsignfoldersignerassociationGetObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationGetObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationGetObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationGetObjectV2Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
}

func (r ApiEzsignfoldersignerassociationGetObjectV2Request) Execute() (*EzsignfoldersignerassociationGetObjectV2Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationGetObjectV2Execute(r)
}

/*
EzsignfoldersignerassociationGetObjectV2 Retrieve an existing Ezsignfoldersignerassociation



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationGetObjectV2Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetObjectV2(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationGetObjectV2Request {
	return ApiEzsignfoldersignerassociationGetObjectV2Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationGetObjectV2Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationGetObjectV2Execute(r ApiEzsignfoldersignerassociationGetObjectV2Request) (*EzsignfoldersignerassociationGetObjectV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationGetObjectV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationGetObjectV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEzsignfoldersignerassociationPatchObjectV1Request struct {
	ctx context.Context
	ApiService *ObjectEzsignfoldersignerassociationAPIService
	pkiEzsignfoldersignerassociationID int32
	ezsignfoldersignerassociationPatchObjectV1Request *EzsignfoldersignerassociationPatchObjectV1Request
}

func (r ApiEzsignfoldersignerassociationPatchObjectV1Request) EzsignfoldersignerassociationPatchObjectV1Request(ezsignfoldersignerassociationPatchObjectV1Request EzsignfoldersignerassociationPatchObjectV1Request) ApiEzsignfoldersignerassociationPatchObjectV1Request {
	r.ezsignfoldersignerassociationPatchObjectV1Request = &ezsignfoldersignerassociationPatchObjectV1Request
	return r
}

func (r ApiEzsignfoldersignerassociationPatchObjectV1Request) Execute() (*EzsignfoldersignerassociationPatchObjectV1Response, *http.Response, error) {
	return r.ApiService.EzsignfoldersignerassociationPatchObjectV1Execute(r)
}

/*
EzsignfoldersignerassociationPatchObjectV1 Patch an existing Ezsignfoldersignerassociation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkiEzsignfoldersignerassociationID
 @return ApiEzsignfoldersignerassociationPatchObjectV1Request
*/
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationPatchObjectV1(ctx context.Context, pkiEzsignfoldersignerassociationID int32) ApiEzsignfoldersignerassociationPatchObjectV1Request {
	return ApiEzsignfoldersignerassociationPatchObjectV1Request{
		ApiService: a,
		ctx: ctx,
		pkiEzsignfoldersignerassociationID: pkiEzsignfoldersignerassociationID,
	}
}

// Execute executes the request
//  @return EzsignfoldersignerassociationPatchObjectV1Response
func (a *ObjectEzsignfoldersignerassociationAPIService) EzsignfoldersignerassociationPatchObjectV1Execute(r ApiEzsignfoldersignerassociationPatchObjectV1Request) (*EzsignfoldersignerassociationPatchObjectV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EzsignfoldersignerassociationPatchObjectV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectEzsignfoldersignerassociationAPIService.EzsignfoldersignerassociationPatchObjectV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"pkiEzsignfoldersignerassociationID"+"}", url.PathEscape(parameterValueToString(r.pkiEzsignfoldersignerassociationID, "pkiEzsignfoldersignerassociationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pkiEzsignfoldersignerassociationID < 0 {
		return localVarReturnValue, nil, reportError("pkiEzsignfoldersignerassociationID must be greater than 0")
	}
	if r.ezsignfoldersignerassociationPatchObjectV1Request == nil {
		return localVarReturnValue, nil, reportError("ezsignfoldersignerassociationPatchObjectV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ezsignfoldersignerassociationPatchObjectV1Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CommonResponseError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
